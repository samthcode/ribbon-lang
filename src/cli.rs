//! This module dicates the Command Line Argument Parser used to run the Ribbon REPL and to run Ribbon Files.
//!
//! This was made using the clap crate on crates.io ([clap](https://crates.io/crates/clap))
//!
//! # Usage
//!
//! ```rust
//! ribbon::cli::run();
//! ```

use crate::Interpreter;
use clap::{AppSettings, Parser, Subcommand};
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[clap(
    name = "ribbon",
    about = "A programming language designed for the future and made to be written quickly."
)]
struct Cli {
    #[clap(subcommand)]
    command: Option<Commands>,
    /// The .rbn file to run
    #[clap(parse(from_os_str), default_value = "src/main.rbn")]
    file: PathBuf,
    #[clap(long, short = 't')]
    /// Should the tokens generated by the lexer be shown after lexing
    tokens: bool,
    #[clap(long, short = 'a')]
    /// Should the ast generated by the parser be shown after parsing
    ast: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Runs the Ribbon Interpreter on the given file
    Run {
        /// The .rbn file to run
        #[clap(parse(from_os_str), default_value = "src/main.rbn")]
        file: PathBuf,
        #[clap(long, short = 't')]
        /// Should the tokens generated by the lexer be shown after lexing
        tokens: bool,
        #[clap(long, short = 'a')]
        /// Should the ast generated by the parser be shown after parsing
        ast: bool,
    },
    /// Opens the REPL to test functions or get to grips with the Ribbon language!
    Repl,
    /// Interpret a single line of Ribbon code
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Expr {
        expr: String,
        #[clap(long, short = 't')]
        /// Should the tokens generated by the lexer be shown after lexing
        tokens: bool,
        #[clap(long, short = 'a')]
        /// Should the ast generated by the parser be shown after parsing
        ast: bool,
    },
    /// Creates a new Ribbon project
    New {
        /// The name of the project you want to create
        project_name: String,
    },
}

fn run_command(file: &Path, tokens: bool, ast: bool) {
    println!(
        "So you want me to run this file: {}, With{} tokens shown and{} ast shown?",
        *file.as_os_str().to_str().as_ref().unwrap(),
        if !tokens { " no" } else { "" },
        if !ast { " no" } else { "" }
    );
}

/// Runs the CLAP. This should only be done once in a program
pub fn run() {
    let args = Cli::parse();

    use Commands::*;
    if let Some(command) = args.command {
        match command {
            Run { file, tokens, ast } => run_command(&file, tokens, ast),
            Repl => {
                panic!("No REPL ATM, Sorry :(");
            }
            Expr { expr, tokens, ast } => {
                // TODO: Add mode to the Interpreter and Evaluator to allow continuous feeding of expressions into the program
                // TODO: So that it doesn't have to be cheesed like this
                Interpreter::with_options(expr.as_str(), "expr", tokens, ast).interpret();
            }
            New { project_name } => {
                println!("Creating new project with name: '{project_name}'")
            }
        }
    } else {
        run_command(&args.file, args.tokens, args.ast)
    }
}
